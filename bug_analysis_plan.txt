Bug分析和修复方案

=== 重新分析ITM处理逻辑 ===
ITM_keymap.json映射:
- sku → sku (必须)
- shortDescription → itemName 
- salePrice → price1
- unitOfMeasure → unit
- effectiveDate → rsrvTxt3

问题文件ITM12NEO52DUG250830101231.json内容分析:
- sku: "7501040083204" ✓ 有效
- shortDescription: "" ❌ 空字符串，被过滤
- salePrice: "0" ❌ 零值，被过滤  
- unitOfMeasure: "" ❌ 空字符串，被过滤
- effectiveDate: "20250831" ✓ 有效，但是未来日期

=== 处理流程分析 ===
1. replace_keys() - 过滤空值和零值，只保留sku和effectiveDate(→rsrvTxt3)
2. process_values() - effectiveDate是未来日期，整个item被if_refresh()返回None
3. 最终processed_json = []，不进行集成，不记录到historical_files

=== PRM场景检查需要 ===
需要检查是否有类似的PRM文件导致相同问题

=== 修复方案概要 ===
1. 改进日志：明确显示文件被跳过的原因
2. 历史记录：无论是否有有效项目，下载的文件都应记录到historical_files
3. 细化判断：区分"无有效字段"和"有效字段但不需要立即处理"

=== ITM文件详细处理流程 ===
ITM12NEO52DUG250830101231.json处理过程:

1. replace_keys()后剩余字段:
   - sku: "7501040083204"
   - rsrvTxt3: "20250831" (effectiveDate映射)

2. process_values()中:
   - 移除lineNumber
   - sku存在，继续处理
   - rsrvTxt3="20250831"，转换为日期2025-08-31
   - 当前时间2025-08-30，rsrv_date > today_date
   - 因为没有price1和itemName，if_refresh()返回None
   - item被丢弃

结论：这个ITM文件确实没有有效的处理项目，因为缺少price1和itemName

=== PRM场景分析 ===
PRM_keymap.json映射:
- itemSku → sku (必须)
- startDate → promoDateFrom  
- endDate → promoDateTo
- requiredQuantity → rsrvInt1
- discount → rsrvDec1
- percent → rsrvDec2
- discountType → rsrvTxt1
- description → promoReason
- type → saleMode

检查PRM12NEO52RSW250808144813.json:
- 所有promotion items都有有效的itemSku, startDate, endDate, discount等
- percent字段为"000.00"，但不是必需字段
- startDate和endDate都不是零值
- 这个PRM文件应该能正常处理，不存在类似ITM的问题

PRM潜在问题场景:
- 如果所有必要字段都为零值或空值
- 如果所有promotion的startDate都是未来日期

=== 完整修复方案 ===

问题根因：
成功下载但没有有效处理项目的文件未被记录到historical_files，导致重复下载

**重要考虑 - 集成失败的情况**：
如果文件下载成功但integration失败（网络问题、API错误等），我们是否应该记录到historical_files？

当前代码逻辑（bara_integrationV2.py:138-152）：
- 集成失败时会从historical_files中**移除**文件名
- 这样下次运行时会重新尝试这个文件
- 这个逻辑是正确的，应该保持

修复策略（重新修正）：
1. **成功集成** → 记录到historical_files ✓
2. **无有效项目但文件本身正常** → 记录到historical_files ✓ (当前bug)
3. **集成失败（临时问题）** → 不记录到historical_files ✓ (保持现状)
4. **文件格式错误等永久问题** → 需要特别标记，避免重复尝试

核心区分：
- **文件层面的问题**：无有效数据但文件格式正确 → 应该记录
- **集成层面的问题**：数据正常但API失败 → 不应该记录，允许重试

具体实施方案：

**修正后的实施方案**：

A. 修改bara_integrationV2.py主循环逻辑:
   ```python
   if processed_json != []:
       # 正常集成流程
       response = send_integration(...)
       if "errorCode" in response:
           # 集成失败 - 保持现有逻辑（从historical_files移除，允许重试）
   else:
       # 无有效项目 - 文件正常但无需处理的数据
       print(f"⚠ {document_names[i]} - No valid items to process, marked as processed")
       write_log(document_names[i], "skipped", customer_code, store_code, "No valid items")
       add_to_historical_files(document_names[i], store_code)  # 关键：避免重复下载
   ```

B. 保持现有集成失败处理逻辑不变:
   - API失败时从historical_files移除文件名
   - 下次运行时重新尝试
   - 这是正确的行为

C. 改进日志信息:
   - "✓ Successfully integrated" - 正常集成成功  
   - "⚠ Skipped - No valid items" - 无有效项目，但文件已处理
   - "❌ Integration failed" - 集成失败，将重试
   
D. 区分文件状态:
   - **文件级成功**：下载成功，格式正确 → 记录到historical_files
   - **集成级失败**：数据正常但API失败 → 不记录，允许重试

优点：
- 解决重复下载问题（针对无有效项目的文件）
- 保持集成失败重试机制
- 不影响现有业务逻辑
- 清晰区分不同类型的处理结果